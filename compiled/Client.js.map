{"version":3,"sources":["../src/Client.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gBAUqB,cAAc,yDAAG,SAAS;gBAAE,SAAS,yDAAG,CAAC,WAAW,EAAE,WAAW,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAoJ1D,IAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8CA8BH,gBAAM,UAAU,CAAC,IAAI,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oDA6BV,OAAO,yDAAG,EAAE;;;;;oDAKX,OAAO,yDAAG,EAAE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAqGhC,OAAO,yDAAG,EAAE;oBAAE,IAAI,yDAAG,EAAE;;;;;;;oBAMR,OAAO,yDAAG,EAAE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAsEhB,OAAO,yDAAG,EAAE;;;;;;;;oBAOX,OAAO,yDAAG,EAAE;;;;;;;;;;sBAQ/B,MAAM","file":"Client.js","sourcesContent":["import Events from 'minivents';\r\n\r\nimport Byte from './Byte';\r\nimport Frame from './Frame';\r\nimport Versions from './Versions';\r\nimport FrameTypes from './FrameTypes';\r\nimport Utils from './Utils';\r\n\r\nclass Client\r\n{\r\n    constructor(url, WebSocketClass = WebSocket, protocols = ['v10.stomp', 'v11.stomp'])\r\n    {\r\n        this.ws = new WebSocketClass(url, protocols);\r\n        this.ws.binaryType = 'arraybuffer';\r\n\r\n        this.counter = 0;\r\n        this.connected = false;\r\n        this.heartbeat = {\r\n            outgoing: 10000,\r\n            incoming: 10000\r\n        };\r\n        this.maxWebSocketFrameSize = 16 * 1024;\r\n        this.subscriptions = {};\r\n        this.partialData = '';\r\n\r\n        // applying events mixins to support event handlers\r\n        Events(this);\r\n    }\r\n\r\n    debug(message)\r\n    {\r\n        console.log(message);\r\n    }\r\n\r\n    _transmit(command, headers, body)\r\n    {\r\n        let out = Frame.marshall(command, headers, body);\r\n\r\n        if(typeof this.debug === 'function')\r\n        {\r\n            this.debug(`>>> ${out}`);\r\n        }\r\n\r\n        while(true)\r\n        {\r\n            if(out.length > this.maxWebSocketFrameSize)\r\n            {\r\n                this.ws.send(out.substring(0, this.maxWebSocketFrameSize));\r\n\r\n                out = out.substring(this.maxWebSocketFrameSize);\r\n\r\n                if(typeof this.debug === 'function')\r\n                {\r\n                    this.debug(`remaining = ${out.length}`);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                return this.ws.send(out);\r\n            }\r\n        }\r\n    }\r\n\r\n    _setupHeartBeat(headers)\r\n    {\r\n        if([Versions.V1_1, Versions.V1_2].indexOf(headers.version) >= 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        let serverOutgoing, serverIncoming;\r\n        [serverOutgoing, serverIncoming] = headers['heart-beat'].split(',').map((v) =>\r\n        {\r\n            return parseInt(v);\r\n        });\r\n\r\n        let ttl;\r\n        if(this.heartbeat.outgoing == 0 || serverIncoming == 0)\r\n        {\r\n            ttl = Math.max(this.heartbeat.outgoing, serverIncoming);\r\n\r\n            if(typeof this.debug === 'function')\r\n            {\r\n                this.debug(`send PING every ${ttl}ms`);\r\n            }\r\n\r\n            this.pinger = Utils.repeatEvery(ttl, () =>\r\n            {\r\n                this.ws.send(Byte.LF);\r\n\r\n                if(typeof this.debug === 'function')\r\n                {\r\n                    this.debug(`>>> PING`);\r\n                }\r\n            });\r\n        }\r\n\r\n        if(this.heartbeat.incoming == 0 || serverOutgoing == 0)\r\n        {\r\n            ttl = Math.max(this.heartbeat.incoming, serverOutgoing);\r\n\r\n            if(typeof this.debug === 'function')\r\n            {\r\n                this.debug(`check PONG every ${ttl}ms`);\r\n            }\r\n\r\n            this.ponger = Utils.repeatEvery(ttl, () =>\r\n            {\r\n                let delta = Utils.now() - this.serverActivity;\r\n\r\n                if(delta > ttl * 2)\r\n                {\r\n                    if(typeof this.debug === 'function')\r\n                    {\r\n                        this.debug(`did not receive server activity for the last ${delta}ms`);\r\n                    }\r\n\r\n                    this.ws.close();\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    connect(headers)\r\n    {\r\n        if(typeof this.debug === 'function')\r\n        {\r\n            this.debug(`Opening Web Socket...`);\r\n        }\r\n\r\n        this.ws.onopen = (evt) =>\r\n        {\r\n            if(typeof this.debug === 'function')\r\n            {\r\n             this.debug(`Web Socket Opened...`);\r\n            }\r\n\r\n            headers['accept-version'] = Versions.supportedVersions();\r\n            headers['heart-beat'] = [this.heartbeat.outgoing, this.heartbeat.incoming].join(',');\r\n\r\n            this._transmit(FrameTypes.CONNECT, headers);\r\n        };\r\n\r\n        this.ws.onmessage = (evt) =>\r\n        {\r\n            let data, arr;\r\n\r\n            if(typeof(ArrayBuffer) != 'undefined' && evt.data instanceof ArrayBuffer)\r\n            {\r\n                let arr = new Uint8Array(evt.data) ;\r\n\r\n                if(typeof this.debug === 'function')\r\n                {\r\n                    this.debug(`--- got data length: ${arr.length}`);\r\n                }\r\n\r\n                let results = [];\r\n\r\n                for(let c of arr)\r\n                {\r\n                    results.push(String.fromCharCode(c));\r\n                }\r\n\r\n                data = results.join('');\r\n            }\r\n            else\r\n            {\r\n                data = evt.data;\r\n            }\r\n\r\n            this.serverActivity = Utils.now();\r\n\r\n            if(data == Byte.LF)\r\n            {\r\n                if(typeof this.debug === 'function')\r\n                {\r\n                    this.debug(`<<< PONG`);\r\n                }\r\n\r\n                return;\r\n            }\r\n\r\n            if(typeof this.debug === 'function')\r\n            {\r\n                this.debug(`<<< ${data}`);\r\n            }\r\n\r\n            let results = [];\r\n            for(let frame of Frame.unmarshall(data))\r\n            {\r\n                switch(frame.command)\r\n                {\r\n                    case FrameTypes.CONNECTED:\r\n                        if(typeof this.debug === 'function')\r\n                        {\r\n                            this.debug(`connected to server ${frame.headers.server}`);\r\n                        }\r\n\r\n                        this.connected = true;\r\n                        this._setupHeartBeat(frame.headers);\r\n\r\n                        this.emit('connection', frame);\r\n\r\n                        break;\r\n\r\n                    case FrameTypes.MESSAGE:\r\n                        let subscription = frame.headers.subscription;\r\n\r\n                        let onreceive = this.subscriptions[subscription] || this.onreceive;\r\n\r\n                        this.emit('message', frame);\r\n\r\n                        if(onreceive)\r\n                        {\r\n                            let client = this;\r\n                            let messageID = frame.headers['message-id'];\r\n\r\n                            frame.ack = (headers = {}) =>\r\n                            {\r\n                                return client.ack(messageID, subscription, headers);\r\n                            };\r\n\r\n                            frame.nack = (headers = {}) =>\r\n                            {\r\n                                return client.nack(messageID, subscription, headers);\r\n                            };\r\n\r\n                            onreceive(frame);\r\n                        }\r\n                        else\r\n                        {\r\n                            if(typeof this.debug === 'function')\r\n                            {\r\n                                this.debug(`Unhandled received MESSAGE: ${frame}`);\r\n                            }\r\n                        }\r\n                        break;\r\n\r\n                    case FrameTypes.RECEIPT:\r\n                        if(typeof this.onreceipt === 'function')\r\n                        {\r\n                            this.onreceipt(frame);\r\n                        }\r\n\r\n                        this.emit('receipt', frame);\r\n\r\n                        break;\r\n\r\n                    case FrameTypes.ERROR:\r\n\r\n                        this.emit('error', frame);\r\n\r\n                        break;\r\n\r\n                    default:\r\n                        if(typeof this.debug === 'function')\r\n                        {\r\n                            this.debug(`Unhandled frame: ${frame}`);\r\n                        }\r\n                }\r\n            }\r\n        }\r\n\r\n        this.ws.onclose = (evt) =>\r\n        {\r\n            let didConnectionFail = !evt.wasClean || !this.connected ? true : false;\r\n\r\n            let msg = `Whoops! Lost connection to ${this.ws.url}`;\r\n\r\n            if(typeof this.debug === 'function')\r\n            {\r\n                this.debug(msg);\r\n            }\r\n\r\n            this._cleanUp();\r\n\r\n            if(didConnectionFail)\r\n            {\r\n                this.emit('connection_failed', {\r\n                    code: evt.code,\r\n                    reason: evt.reason\r\n                });\r\n            }\r\n            else\r\n            {\r\n                this.emit('connection_error', {\r\n                    code: evt.code,\r\n                    reason: evt.reason\r\n                });\r\n            }\r\n        };\r\n    }\r\n\r\n    disconnect()\r\n    {\r\n        this._transmit(FrameTypes.DISCONNECT);\r\n\r\n        let client = this;\r\n\r\n        this.ws.onclose = function(evt)\r\n        {\r\n            client.emit('disconnect');\r\n        };\r\n\r\n        this.ws.close();\r\n        this._cleanUp();\r\n    }\r\n\r\n    _cleanUp()\r\n    {\r\n        this.connected = false;\r\n\r\n        if(this.pinger)\r\n        {\r\n            Utils.stopRepeatation(this.pinger);\r\n        }\r\n\r\n        if(this.ponger)\r\n        {\r\n            Utils.stopRepeatation(this.ponger);\r\n        }\r\n    }\r\n\r\n    send(destination, headers = {}, body = '')\r\n    {\r\n        headers.destination = destination;\r\n        return this._transmit(FrameTypes.SEND, headers, body);\r\n    }\r\n\r\n    subscribe(destination, callback, headers = {})\r\n    {\r\n        if(!headers.id)\r\n        {\r\n            headers.id = 'sub-' + this.counter++;\r\n        }\r\n\r\n        headers.destination = destination;\r\n\r\n        this.subscriptions[headers.id] = callback;\r\n\r\n        this._transmit(FrameTypes.SUBSCRIBE, headers);\r\n\r\n        let client = this;\r\n\r\n        return {\r\n            id: headers.id,\r\n            unsubscribe: function()\r\n            {\r\n                return client.unsubscribe(headers.id);\r\n            }\r\n        };\r\n    }\r\n\r\n    unsubscribe(id)\r\n    {\r\n        delete this.subscriptions[id];\r\n\r\n        this._transmit(FrameTypes.UNSUBSCRIBE, {\r\n            id: id\r\n        });\r\n    }\r\n\r\n    begin(transaction)\r\n    {\r\n        let txid = transaction || 'tx' + this.counter++;\r\n\r\n        this._transmit(FrameTypes.BEGIN, {\r\n            transaction: txid\r\n        });\r\n\r\n        let client = this;\r\n\r\n        return {\r\n            id: txid,\r\n            commit: function()\r\n            {\r\n                return client.commit(txid);\r\n            },\r\n            abort: function()\r\n            {\r\n                return client.abort(txid);\r\n            }\r\n        };\r\n    }\r\n\r\n    commit(transaction)\r\n    {\r\n        return this._transmit(FrameTypes.COMMIT, {\r\n            transaction: transaction\r\n        });\r\n    }\r\n\r\n    abort(transaction)\r\n    {\r\n        return this._transmit(FrameTypes.ABORT, {\r\n            transaction: transaction\r\n        });\r\n    }\r\n\r\n    ack(messageID, subscription, headers = {})\r\n    {\r\n        headers['message-id'] = messageID;\r\n        headers.subscription = subscription;\r\n        return this._transmit(FrameTypes.ACK, headers);\r\n    }\r\n\r\n    nack(messageID, subscription, headers = {})\r\n    {\r\n        headers['message-id'] = messageID;\r\n        headers.subscription = subscription;\r\n        return this._transmit(FrameTypes.NACK, headers);\r\n    }\r\n}\r\n\r\nexport default Client;\r\n"]}