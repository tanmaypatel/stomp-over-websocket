{"version":3,"sources":["../src/Client.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sDAgIqB,IAAI;AAAJ,4BAAI;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uDAiCV,IAAI;AAAJ,4BAAI;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qDA2BU,IAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kDA8BH,gBAAM,UAAU,CAAC,IAAI,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;wDAwBV,OAAO,yDAAG,EAAE;;;;;wDAKX,OAAO,yDAAG,EAAE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wBAmGhC,OAAO,yDAAG,EAAE;wBAAE,IAAI,yDAAG,EAAE;;;;;;;wBAMR,OAAO,yDAAG,EAAE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wBAsEhB,OAAO,yDAAG,EAAE;;;;;;;;wBAOX,OAAO,yDAAG,EAAE;;;;;;;;;;0BAQ/B,MAAM","file":"Client.js","sourcesContent":["import Byte from './Byte';\r\nimport Frame from './Frame';\r\nimport Stomp from './Stomp';\r\n\r\nlet now = ()=>\r\n{\r\n    if(Date.now)\r\n    {\r\n        return Date.now();\r\n    }\r\n    else\r\n    {\r\n        return new Date().valueOf;\r\n    }\r\n}\r\n\r\nclass Client\r\n{\r\n    constructor(ws)\r\n    {\r\n        this.ws = ws;\r\n        this.ws.binaryType = 'arraybuffer';\r\n\r\n        this.counter = 0;\r\n        this.connected = false;\r\n        this.heartbeat = {\r\n            outgoing: 10000,\r\n            incoming: 10000\r\n        };\r\n        this.maxWebSocketFrameSize = 16 * 1024;\r\n        this.subscriptions = {};\r\n        this.partialData = '';\r\n    }\r\n\r\n    debug(message)\r\n    {\r\n        console.log(message);\r\n    }\r\n\r\n    _transmit(command, headers, body)\r\n    {\r\n        let out = Frame.marshall(command, headers, body);\r\n\r\n        if(typeof this.debug === 'function')\r\n        {\r\n            this.debug(`>>> ${out}`);\r\n        }\r\n\r\n        while(true)\r\n        {\r\n            if(out.length > this.maxWebSocketFrameSize)\r\n            {\r\n                this.ws.send(out.substring(0, this.maxWebSocketFrameSize));\r\n\r\n                out = out.substring(this.maxWebSocketFrameSize);\r\n\r\n                if(typeof this.debug === 'function')\r\n                {\r\n                    this.debug(`remaining = ${out.length}`);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                return this.ws.send(out);\r\n            }\r\n        }\r\n    }\r\n\r\n    _setupHeartBeat(headers)\r\n    {\r\n        if([Stomp.VERSIONS.V1_1, Stomp.VERSIONS.V1_2].indexOf(headers.version) >= 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        let serverOutgoing, serverIncoming;\r\n        [serverOutgoing, serverIncoming] = headers['heart-beat'].split(',').map((v) =>\r\n        {\r\n            return parseInt(v);\r\n        });\r\n\r\n        let ttl;\r\n        if(this.heartbeat.outgoing == 0 || serverIncoming == 0)\r\n        {\r\n            ttl = Math.max(this.heartbeat.outgoing, serverIncoming);\r\n\r\n            if(typeof this.debug === 'function')\r\n            {\r\n                this.debug(`send PING every ${ttl}ms`);\r\n            }\r\n\r\n            this.pinger = Stomp.setInterval(ttl, () =>\r\n            {\r\n                this.ws.send(Byte.LF);\r\n\r\n                if(typeof this.debug === 'function')\r\n                {\r\n                    this.debug(`>>> PING`);\r\n                }\r\n            });\r\n        }\r\n\r\n        if(this.heartbeat.incoming == 0 || serverOutgoing == 0)\r\n        {\r\n            ttl = Math.max(this.heartbeat.incoming, serverOutgoing);\r\n\r\n            if(typeof this.debug === 'function')\r\n            {\r\n                this.debug(`check PONG every ${ttl}ms`);\r\n            }\r\n\r\n            this.ponger = Stomp.setInterval(ttl, () =>\r\n            {\r\n                let delta = now() - this.serverActivity;\r\n\r\n                if(delta > ttl * 2)\r\n                {\r\n                    if(typeof this.debug === 'function')\r\n                    {\r\n                        this.debug(`did not receive server activity for the last ${delta}ms`);\r\n                    }\r\n\r\n                    this.ws.close();\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    _parseConnect(...args)\r\n    {\r\n        let headers = {};\r\n        let connectCallback = null;\r\n        let errorCallback = null;\r\n\r\n        switch(args.length)\r\n        {\r\n            case 2:\r\n                [headers, connectCallback] = args;\r\n                break;\r\n\r\n            case 3:\r\n                if(args[1] instanceof Function)\r\n                {\r\n                    [headers, connectCallback, errorCallback] = args;\r\n                }\r\n                else\r\n                {\r\n                    [headers.login, headers.passcode, connectCallback] = args;\r\n                }\r\n                break;\r\n            case 4:\r\n                [headers.login, headers.passcode, connectCallback, errorCallback] = args;\r\n                break;\r\n            default:\r\n                [headers.login, headers.passcode, connectCallback, errorCallback, headers.host] = args;\r\n                break;\r\n        }\r\n\r\n        return [headers, connectCallback, errorCallback];\r\n    }\r\n\r\n    connect(...args)\r\n    {\r\n        let out = this._parseConnect(args);\r\n        let headers, errorCallback;\r\n\r\n        [headers, this.connectCallback, errorCallback] = out;\r\n\r\n        if(typeof this.debug === 'function')\r\n        {\r\n            this.debug(`Opening Web Socket...`);\r\n        }\r\n\r\n        this.ws.onmessage = (evt) =>\r\n        {\r\n            let data, arr;\r\n\r\n            if(typeof(ArrayBuffer) != 'undefined' && evt.data instanceof ArrayBuffer)\r\n            {\r\n                let arr = new Uint8Array(evt.data) ;\r\n\r\n                if(typeof this.debug === 'function')\r\n                {\r\n                    this.debug(`--- got data length: ${arr.length}`);\r\n                }\r\n\r\n                let results = [];\r\n\r\n                for(let c of arr)\r\n                {\r\n                    results.push(String.fromCharCode(c));\r\n                }\r\n\r\n                data = results.join('');\r\n            }\r\n            else\r\n            {\r\n                data = event.data;\r\n            }\r\n\r\n            this.serverActivity = now();\r\n\r\n            if(data == Byte.LF)\r\n            {\r\n                if(typeof this.debug === 'function')\r\n                {\r\n                    this.debug(`<<< PONG`);\r\n                }\r\n\r\n                return;\r\n            }\r\n\r\n            if(typeof this.debug === 'function')\r\n            {\r\n                this.debug(`<<< ${data}`);\r\n            }\r\n\r\n            let results = [];\r\n            for(let frame of Frame.unmarshall(data))\r\n            {\r\n                switch(frame.command)\r\n                {\r\n                    case 'CONNECTED':\r\n                        if(typeof this.debug === 'function')\r\n                        {\r\n                            this.debug(`connected to server ${frame.headers.server}`);\r\n                        }\r\n\r\n                        this.connected = true;\r\n                        this._setupHeartBeat(frame.headers);\r\n                        results.push(typeof this.debug === 'function' ? this.connectCallback(frame) : void 0);\r\n                        break;\r\n\r\n                    case 'MESSAGE':\r\n                        let subscription = frame.headers.subscription;\r\n                        let onreceive = this.subscriptions[subscription] || this.onreceive;\r\n\r\n                        if(onreceive)\r\n                        {\r\n                            let client = this;\r\n                            let messageID = frame.headers['message-id'];\r\n\r\n                            frame.ack = (headers = {}) =>\r\n                            {\r\n                                return client.ack(messageID, subscription, headers);\r\n                            };\r\n\r\n                            frame.nack = (headers = {}) =>\r\n                            {\r\n                                return client.nack(messageID, subscription, headers);\r\n                            };\r\n                        }\r\n                        else\r\n                        {\r\n                            if(typeof this.debug === 'function')\r\n                            {\r\n                                this.debug(`Unhandled received MESSAGE: ${frame}`);\r\n                            }\r\n                        }\r\n                        break;\r\n\r\n                    case 'RECEIPT':\r\n                        if(typeof this.onreceipt === 'function')\r\n                        {\r\n                            this.onreceipt(frame);\r\n                        }\r\n\r\n                        break;\r\n\r\n                    case 'ERROR':\r\n                        if(typeof errorCallback === 'function')\r\n                        {\r\n                            errorCallback(frame);\r\n                        }\r\n\r\n                        break;\r\n\r\n                    default:\r\n                        if(typeof this.debug === 'function')\r\n                        {\r\n                            this.debug(`Unhandled frame: ${frame}`);\r\n                        }\r\n                }\r\n            }\r\n        }\r\n\r\n        this.ws.onclose = () =>\r\n        {\r\n             let msg = `Whoops! Lost connection to ${this.ws.url}`;\r\n\r\n             if(typeof this.debug === 'function')\r\n             {\r\n                 this.debug(msg);\r\n             }\r\n\r\n             this._cleanup();\r\n\r\n             if(typeof errorCallback === 'function')\r\n             {\r\n                 errorCallback(msg);\r\n             }\r\n        };\r\n\r\n        this.ws.onopen = () =>\r\n        {\r\n             if(typeof this.debug === 'function')\r\n             {\r\n                 this.debug(`Web Socket Opened...`);\r\n             }\r\n\r\n             headers['accept-version'] = Stomp.VERSIONS.supportedVersions();\r\n             headers['heart-beat'] = [this.heartbeat.outgoing, this.heartbeat.incoming].join(',');\r\n\r\n             this._transmit('CONNECT', headers);\r\n        };\r\n    }\r\n\r\n    disconnect(disconnectCallback)\r\n    {\r\n        this._transmit('DISCONNECT');\r\n\r\n        this.ws.onclose = null;\r\n        this.ws.close();\r\n        this._cleanup();\r\n\r\n        if(typeof disconnectCallback === 'function')\r\n        {\r\n            disconnectCallback();\r\n        }\r\n    }\r\n\r\n    _cleanUp()\r\n    {\r\n        this.connected = false;\r\n\r\n        if(this.pinger)\r\n        {\r\n            Stomp.clearInterval(this.pinger);\r\n        }\r\n\r\n        if(this.ponger)\r\n        {\r\n            Stomp.clearInterval(this.ponger);\r\n        }\r\n    }\r\n\r\n    send(destination, headers = {}, body = '')\r\n    {\r\n        headers.destination = destination;\r\n        return this._transmit('SEND', headers, body);\r\n    }\r\n\r\n    subscribe(destination, callback, headers = {})\r\n    {\r\n        if(!headers.id)\r\n        {\r\n            headers.id = 'sub-' + this.counter++;\r\n        }\r\n\r\n        headers.destination = destination;\r\n\r\n        this.subscriptions[headers.id] = callback;\r\n\r\n        this._transmit('SUBSCRIBE', headers);\r\n\r\n        let client = this;\r\n\r\n        return {\r\n            id: headers.id,\r\n            unsubscribe: function()\r\n            {\r\n                return client.unsubscribe(headers.id);\r\n            }\r\n        };\r\n    }\r\n\r\n    unsubscribe(id)\r\n    {\r\n        delete this.subscriptions[id];\r\n\r\n        this._transmit('UNSUBSCRIBE', {\r\n            id: id\r\n        });\r\n    }\r\n\r\n    begin(transaction)\r\n    {\r\n        let txid = transaction || 'tx' + this.counter++;\r\n\r\n        this._transmit('BEGIN', {\r\n            transaction: txid\r\n        });\r\n\r\n        let client = this;\r\n\r\n        return {\r\n            id: txid,\r\n            commit: function()\r\n            {\r\n                return client.commit(txid);\r\n            },\r\n            abort: function()\r\n            {\r\n                return client.abort(txid);\r\n            }\r\n        };\r\n    }\r\n\r\n    commit(transaction)\r\n    {\r\n        return this._transmit('COMMIT', {\r\n            transaction: transaction\r\n        });\r\n    }\r\n\r\n    abort(transaction)\r\n    {\r\n        return this._transmit('ABORT', {\r\n            transaction: transaction\r\n        });\r\n    }\r\n\r\n    ack(messageID, subscription, headers = {})\r\n    {\r\n        headers['message-id'] = messageID;\r\n        headers.subscription = subscription;\r\n        return this._transmit('ACK', headers);\r\n    }\r\n\r\n    nack(messageID, subscription, headers = {})\r\n    {\r\n        headers['message-id'] = messageID;\r\n        headers.subscription = subscription;\r\n        return this._transmit('NACK', headers);\r\n    }\r\n}\r\n\r\nexport default Client;\r\n"]}