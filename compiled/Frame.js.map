{"version":3,"sources":["../src/Frame.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iCAcoB,WAAW,CAAC,OAAO,EAAE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0CAoDjB,KAAK,CAAC,KAAK,CAAC,IAAI,MAAM,MAAI,eAAK,IAAI,GAAG,eAAK,EAAE,OAAI,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gBAkBjD,OAAO,yDAAG,EAAE;gBAAE,IAAI,yDAAG,EAAE;;;;;;;;;;;;;;;;;;;;;;;;0CAkBzB,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sBAiBjC,KAAK","file":"Frame.js","sourcesContent":["import Byte from './Byte';\r\n\r\nlet unmarshallSingle = (data) =>\r\n{\r\n    let divider = data.search(new RegExp(`${Byte.LF}${Byte.LF}`));\r\n    let headerLines = data.substring(0, divider).split(Byte.LF);\r\n    let command = headerLines.shift();\r\n    let headers = {};\r\n\r\n    let trim = function(str)\r\n    {\r\n        return str.replace(/^\\s+|\\s+$/g, '');\r\n    };\r\n\r\n    for(let line of headerLines.reverse())\r\n    {\r\n        let idx = line.indexOf(':');\r\n        headers[trim(line.substring(0, idx))] = trim(line.substring(idx + 1));\r\n    }\r\n\r\n    let body = '';\r\n\r\n    let start = divider + 2;\r\n\r\n    if(headers['content-length'])\r\n    {\r\n        let len = parseInt(headers['content-length']);\r\n        body = ('' + data).substring(start, start + len);\r\n    }\r\n    else\r\n    {\r\n        let chr = null;\r\n\r\n        for(let i = start; i <= data.length; i++)\r\n        {\r\n            chr = data.charAt(i);\r\n            if(chr === Byte.NULL)\r\n            {\r\n                break;\r\n            }\r\n\r\n            body += chr;\r\n        }\r\n    }\r\n\r\n    return new Frame(command, headers, body);\r\n};\r\n\r\nclass Frame\r\n{\r\n    static sizeOfUTF8(s)\r\n    {\r\n        if(s)\r\n        {\r\n            return encodeURI(s).split(/%..|./).length - 1;\r\n        }\r\n        else\r\n        {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    static unmarshall(datas)\r\n    {\r\n        let frames = [];\r\n\r\n        for(let data of datas.split(new RegExp(`${Byte.NULL}${Byte.LF}*`)))\r\n        {\r\n            if(data.length > 0)\r\n            {\r\n                frames.push(unmarshallSingle(data));\r\n            }\r\n        }\r\n\r\n        return frames;\r\n    }\r\n\r\n    static marshall(command, headers, body)\r\n    {\r\n        let frame = new Frame(command, headers, body);\r\n\r\n        return frame.toString() + Byte.NULL;\r\n    }\r\n\r\n    constructor(command, headers = {}, body = '')\r\n    {\r\n        this.command = command;\r\n        this.headers = headers;\r\n        this.body = body;\r\n    }\r\n\r\n    toString()\r\n    {\r\n        let lines = [this.command];\r\n\r\n        let skipContentLength = this.headers['content-length'] === false ? true : false;\r\n\r\n        if(skipContentLength)\r\n        {\r\n            delete this.headers['content-length'];\r\n        }\r\n\r\n        for(let key of Object.keys(this.headers))\r\n        {\r\n            let value = this.headers[key];\r\n            lines.push(`${key}:${value}`);\r\n        }\r\n\r\n        if(this.body && !skipContentLength)\r\n        {\r\n            lines.push(`content-length:${Frame.sizeOfUTF8(this.body)}`);\r\n        }\r\n\r\n        lines.push(Byte.LF + this.body);\r\n\r\n        return lines.join(Byte.LF);\r\n    }\r\n}\r\n\r\nexport default Frame;\r\n"]}